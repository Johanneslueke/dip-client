// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vorgang.sql

package db

import (
	"context"
	"database/sql"
)

const countVorgaenge = `-- name: CountVorgaenge :one
SELECT COUNT(*) FROM vorgang
WHERE 
    (? IS NULL OR aktualisiert >= ?)
    AND (? IS NULL OR aktualisiert <= ?)
    AND (? IS NULL OR datum >= ?)
    AND (? IS NULL OR datum <= ?)
    AND (? IS NULL OR wahlperiode = ?)
    AND (? IS NULL OR vorgangstyp = ?)
    AND (? IS NULL OR gesta = ?)
`

type CountVorgaengeParams struct {
	Column1        interface{}    `json:"column_1"`
	Aktualisiert   string         `json:"aktualisiert"`
	Column3        interface{}    `json:"column_3"`
	Aktualisiert_2 string         `json:"aktualisiert_2"`
	Column5        interface{}    `json:"column_5"`
	Datum          sql.NullString `json:"datum"`
	Column7        interface{}    `json:"column_7"`
	Datum_2        sql.NullString `json:"datum_2"`
	Column9        interface{}    `json:"column_9"`
	Wahlperiode    int64          `json:"wahlperiode"`
	Column11       interface{}    `json:"column_11"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Column13       interface{}    `json:"column_13"`
	Gesta          sql.NullString `json:"gesta"`
}

func (q *Queries) CountVorgaenge(ctx context.Context, arg CountVorgaengeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVorgaenge,
		arg.Column1,
		arg.Aktualisiert,
		arg.Column3,
		arg.Aktualisiert_2,
		arg.Column5,
		arg.Datum,
		arg.Column7,
		arg.Datum_2,
		arg.Column9,
		arg.Wahlperiode,
		arg.Column11,
		arg.Vorgangstyp,
		arg.Column13,
		arg.Gesta,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInkrafttreten = `-- name: CreateInkrafttreten :one
INSERT INTO inkrafttreten (vorgang_id, datum, erlaeuterung)
VALUES (?, ?, ?)
RETURNING id, vorgang_id, datum, erlaeuterung, created_at
`

type CreateInkrafttretenParams struct {
	VorgangID    string         `json:"vorgang_id"`
	Datum        string         `json:"datum"`
	Erlaeuterung sql.NullString `json:"erlaeuterung"`
}

func (q *Queries) CreateInkrafttreten(ctx context.Context, arg CreateInkrafttretenParams) (Inkrafttreten, error) {
	row := q.db.QueryRowContext(ctx, createInkrafttreten, arg.VorgangID, arg.Datum, arg.Erlaeuterung)
	var i Inkrafttreten
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Datum,
		&i.Erlaeuterung,
		&i.CreatedAt,
	)
	return i, err
}

const createVerkuendung = `-- name: CreateVerkuendung :one
INSERT INTO verkuendung (
    vorgang_id, ausfertigungsdatum, verkuendungsdatum, einleitungstext,
    fundstelle, jahrgang, seite, heftnummer, pdf_url, rubrik_nr,
    titel, verkuendungsblatt_bezeichnung, verkuendungsblatt_kuerzel
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, vorgang_id, ausfertigungsdatum, verkuendungsdatum, einleitungstext, fundstelle, jahrgang, seite, heftnummer, pdf_url, rubrik_nr, titel, verkuendungsblatt_bezeichnung, verkuendungsblatt_kuerzel, created_at
`

type CreateVerkuendungParams struct {
	VorgangID                    string         `json:"vorgang_id"`
	Ausfertigungsdatum           string         `json:"ausfertigungsdatum"`
	Verkuendungsdatum            string         `json:"verkuendungsdatum"`
	Einleitungstext              string         `json:"einleitungstext"`
	Fundstelle                   string         `json:"fundstelle"`
	Jahrgang                     string         `json:"jahrgang"`
	Seite                        string         `json:"seite"`
	Heftnummer                   sql.NullString `json:"heftnummer"`
	PdfUrl                       sql.NullString `json:"pdf_url"`
	RubrikNr                     sql.NullString `json:"rubrik_nr"`
	Titel                        sql.NullString `json:"titel"`
	VerkuendungsblattBezeichnung sql.NullString `json:"verkuendungsblatt_bezeichnung"`
	VerkuendungsblattKuerzel     sql.NullString `json:"verkuendungsblatt_kuerzel"`
}

func (q *Queries) CreateVerkuendung(ctx context.Context, arg CreateVerkuendungParams) (Verkuendung, error) {
	row := q.db.QueryRowContext(ctx, createVerkuendung,
		arg.VorgangID,
		arg.Ausfertigungsdatum,
		arg.Verkuendungsdatum,
		arg.Einleitungstext,
		arg.Fundstelle,
		arg.Jahrgang,
		arg.Seite,
		arg.Heftnummer,
		arg.PdfUrl,
		arg.RubrikNr,
		arg.Titel,
		arg.VerkuendungsblattBezeichnung,
		arg.VerkuendungsblattKuerzel,
	)
	var i Verkuendung
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Ausfertigungsdatum,
		&i.Verkuendungsdatum,
		&i.Einleitungstext,
		&i.Fundstelle,
		&i.Jahrgang,
		&i.Seite,
		&i.Heftnummer,
		&i.PdfUrl,
		&i.RubrikNr,
		&i.Titel,
		&i.VerkuendungsblattBezeichnung,
		&i.VerkuendungsblattKuerzel,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgang = `-- name: CreateVorgang :one
INSERT INTO vorgang (
    id, titel, vorgangstyp, typ, abstract, aktualisiert,
    archiv, beratungsstand, datum, gesta, kom, mitteilung,
    ratsdok, sek, wahlperiode
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
`

type CreateVorgangParams struct {
	ID             string         `json:"id"`
	Titel          string         `json:"titel"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Typ            string         `json:"typ"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   string         `json:"aktualisiert"`
	Archiv         sql.NullString `json:"archiv"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullString `json:"datum"`
	Gesta          sql.NullString `json:"gesta"`
	Kom            sql.NullString `json:"kom"`
	Mitteilung     sql.NullString `json:"mitteilung"`
	Ratsdok        sql.NullString `json:"ratsdok"`
	Sek            sql.NullString `json:"sek"`
	Wahlperiode    int64          `json:"wahlperiode"`
}

func (q *Queries) CreateVorgang(ctx context.Context, arg CreateVorgangParams) (Vorgang, error) {
	row := q.db.QueryRowContext(ctx, createVorgang,
		arg.ID,
		arg.Titel,
		arg.Vorgangstyp,
		arg.Typ,
		arg.Abstract,
		arg.Aktualisiert,
		arg.Archiv,
		arg.Beratungsstand,
		arg.Datum,
		arg.Gesta,
		arg.Kom,
		arg.Mitteilung,
		arg.Ratsdok,
		arg.Sek,
		arg.Wahlperiode,
	)
	var i Vorgang
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVorgangDeskriptor = `-- name: CreateVorgangDeskriptor :one
INSERT INTO vorgang_deskriptor (vorgang_id, name, typ, fundstelle)
VALUES (?, ?, ?, ?)
ON CONFLICT (vorgang_id, name, typ) DO UPDATE
SET fundstelle = excluded.fundstelle
RETURNING id, vorgang_id, name, typ, fundstelle, created_at
`

type CreateVorgangDeskriptorParams struct {
	VorgangID  string `json:"vorgang_id"`
	Name       string `json:"name"`
	Typ        string `json:"typ"`
	Fundstelle int64  `json:"fundstelle"`
}

func (q *Queries) CreateVorgangDeskriptor(ctx context.Context, arg CreateVorgangDeskriptorParams) (VorgangDeskriptor, error) {
	row := q.db.QueryRowContext(ctx, createVorgangDeskriptor,
		arg.VorgangID,
		arg.Name,
		arg.Typ,
		arg.Fundstelle,
	)
	var i VorgangDeskriptor
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Name,
		&i.Typ,
		&i.Fundstelle,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgangInitiative = `-- name: CreateVorgangInitiative :exec
INSERT INTO vorgang_initiative (vorgang_id, initiative)
VALUES (?, ?)
`

type CreateVorgangInitiativeParams struct {
	VorgangID  string `json:"vorgang_id"`
	Initiative string `json:"initiative"`
}

func (q *Queries) CreateVorgangInitiative(ctx context.Context, arg CreateVorgangInitiativeParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangInitiative, arg.VorgangID, arg.Initiative)
	return err
}

const createVorgangSachgebiet = `-- name: CreateVorgangSachgebiet :exec
INSERT INTO vorgang_sachgebiet (vorgang_id, sachgebiet)
VALUES (?, ?)
`

type CreateVorgangSachgebietParams struct {
	VorgangID  string `json:"vorgang_id"`
	Sachgebiet string `json:"sachgebiet"`
}

func (q *Queries) CreateVorgangSachgebiet(ctx context.Context, arg CreateVorgangSachgebietParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangSachgebiet, arg.VorgangID, arg.Sachgebiet)
	return err
}

const createVorgangVerlinkung = `-- name: CreateVorgangVerlinkung :one
INSERT INTO vorgang_verlinkung (
    source_vorgang_id, target_vorgang_id, titel, verweisung, gesta, wahlperiode
) VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (source_vorgang_id, target_vorgang_id) DO UPDATE
SET titel = excluded.titel,
    verweisung = excluded.verweisung,
    gesta = excluded.gesta,
    wahlperiode = excluded.wahlperiode
RETURNING id, source_vorgang_id, target_vorgang_id, titel, verweisung, gesta, wahlperiode, created_at
`

type CreateVorgangVerlinkungParams struct {
	SourceVorgangID string         `json:"source_vorgang_id"`
	TargetVorgangID string         `json:"target_vorgang_id"`
	Titel           string         `json:"titel"`
	Verweisung      string         `json:"verweisung"`
	Gesta           sql.NullString `json:"gesta"`
	Wahlperiode     int64          `json:"wahlperiode"`
}

func (q *Queries) CreateVorgangVerlinkung(ctx context.Context, arg CreateVorgangVerlinkungParams) (VorgangVerlinkung, error) {
	row := q.db.QueryRowContext(ctx, createVorgangVerlinkung,
		arg.SourceVorgangID,
		arg.TargetVorgangID,
		arg.Titel,
		arg.Verweisung,
		arg.Gesta,
		arg.Wahlperiode,
	)
	var i VorgangVerlinkung
	err := row.Scan(
		&i.ID,
		&i.SourceVorgangID,
		&i.TargetVorgangID,
		&i.Titel,
		&i.Verweisung,
		&i.Gesta,
		&i.Wahlperiode,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgangZustimmungsbeduerftigkeit = `-- name: CreateVorgangZustimmungsbeduerftigkeit :exec
INSERT INTO vorgang_zustimmungsbeduerftigkeit (vorgang_id, zustimmungsbeduerftigkeit)
VALUES (?, ?)
`

type CreateVorgangZustimmungsbeduerftigkeitParams struct {
	VorgangID                 string `json:"vorgang_id"`
	Zustimmungsbeduerftigkeit string `json:"zustimmungsbeduerftigkeit"`
}

func (q *Queries) CreateVorgangZustimmungsbeduerftigkeit(ctx context.Context, arg CreateVorgangZustimmungsbeduerftigkeitParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangZustimmungsbeduerftigkeit, arg.VorgangID, arg.Zustimmungsbeduerftigkeit)
	return err
}

const deleteVorgang = `-- name: DeleteVorgang :exec
DELETE FROM vorgang WHERE id = ?
`

func (q *Queries) DeleteVorgang(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteVorgang, id)
	return err
}

const getVorgang = `-- name: GetVorgang :one
SELECT id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
FROM vorgang
WHERE id = ?
`

func (q *Queries) GetVorgang(ctx context.Context, id string) (Vorgang, error) {
	row := q.db.QueryRowContext(ctx, getVorgang, id)
	var i Vorgang
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVorgangWithDeskriptor = `-- name: GetVorgangWithDeskriptor :many
SELECT 
    v.id, v.titel, v.vorgangstyp, v.typ, v.abstract, v.aktualisiert, v.archiv, v.beratungsstand, v.datum, v.gesta, v.kom, v.mitteilung, v.ratsdok, v.sek, v.wahlperiode, v.created_at, v.updated_at,
    vd.name as deskriptor_name,
    vd.typ as deskriptor_typ,
    vd.fundstelle as deskriptor_fundstelle
FROM vorgang v
LEFT JOIN vorgang_deskriptor vd ON v.id = vd.vorgang_id
WHERE v.id = ?
`

type GetVorgangWithDeskriptorRow struct {
	ID                   string         `json:"id"`
	Titel                string         `json:"titel"`
	Vorgangstyp          string         `json:"vorgangstyp"`
	Typ                  string         `json:"typ"`
	Abstract             sql.NullString `json:"abstract"`
	Aktualisiert         string         `json:"aktualisiert"`
	Archiv               sql.NullString `json:"archiv"`
	Beratungsstand       sql.NullString `json:"beratungsstand"`
	Datum                sql.NullString `json:"datum"`
	Gesta                sql.NullString `json:"gesta"`
	Kom                  sql.NullString `json:"kom"`
	Mitteilung           sql.NullString `json:"mitteilung"`
	Ratsdok              sql.NullString `json:"ratsdok"`
	Sek                  sql.NullString `json:"sek"`
	Wahlperiode          int64          `json:"wahlperiode"`
	CreatedAt            string         `json:"created_at"`
	UpdatedAt            string         `json:"updated_at"`
	DeskriptorName       sql.NullString `json:"deskriptor_name"`
	DeskriptorTyp        sql.NullString `json:"deskriptor_typ"`
	DeskriptorFundstelle sql.NullInt64  `json:"deskriptor_fundstelle"`
}

func (q *Queries) GetVorgangWithDeskriptor(ctx context.Context, id string) ([]GetVorgangWithDeskriptorRow, error) {
	rows, err := q.db.QueryContext(ctx, getVorgangWithDeskriptor, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVorgangWithDeskriptorRow
	for rows.Next() {
		var i GetVorgangWithDeskriptorRow
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Abstract,
			&i.Aktualisiert,
			&i.Archiv,
			&i.Beratungsstand,
			&i.Datum,
			&i.Gesta,
			&i.Kom,
			&i.Mitteilung,
			&i.Ratsdok,
			&i.Sek,
			&i.Wahlperiode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeskriptorName,
			&i.DeskriptorTyp,
			&i.DeskriptorFundstelle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVorgangWithInitiative = `-- name: GetVorgangWithInitiative :many
SELECT 
    v.id, v.titel, v.vorgangstyp, v.typ, v.abstract, v.aktualisiert, v.archiv, v.beratungsstand, v.datum, v.gesta, v.kom, v.mitteilung, v.ratsdok, v.sek, v.wahlperiode, v.created_at, v.updated_at,
    vi.initiative
FROM vorgang v
LEFT JOIN vorgang_initiative vi ON v.id = vi.vorgang_id
WHERE v.id = ?
`

type GetVorgangWithInitiativeRow struct {
	ID             string         `json:"id"`
	Titel          string         `json:"titel"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Typ            string         `json:"typ"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   string         `json:"aktualisiert"`
	Archiv         sql.NullString `json:"archiv"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullString `json:"datum"`
	Gesta          sql.NullString `json:"gesta"`
	Kom            sql.NullString `json:"kom"`
	Mitteilung     sql.NullString `json:"mitteilung"`
	Ratsdok        sql.NullString `json:"ratsdok"`
	Sek            sql.NullString `json:"sek"`
	Wahlperiode    int64          `json:"wahlperiode"`
	CreatedAt      string         `json:"created_at"`
	UpdatedAt      string         `json:"updated_at"`
	Initiative     sql.NullString `json:"initiative"`
}

func (q *Queries) GetVorgangWithInitiative(ctx context.Context, id string) ([]GetVorgangWithInitiativeRow, error) {
	rows, err := q.db.QueryContext(ctx, getVorgangWithInitiative, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVorgangWithInitiativeRow
	for rows.Next() {
		var i GetVorgangWithInitiativeRow
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Abstract,
			&i.Aktualisiert,
			&i.Archiv,
			&i.Beratungsstand,
			&i.Datum,
			&i.Gesta,
			&i.Kom,
			&i.Mitteilung,
			&i.Ratsdok,
			&i.Sek,
			&i.Wahlperiode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Initiative,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVorgangWithSachgebiet = `-- name: GetVorgangWithSachgebiet :many
SELECT 
    v.id, v.titel, v.vorgangstyp, v.typ, v.abstract, v.aktualisiert, v.archiv, v.beratungsstand, v.datum, v.gesta, v.kom, v.mitteilung, v.ratsdok, v.sek, v.wahlperiode, v.created_at, v.updated_at,
    vs.sachgebiet
FROM vorgang v
LEFT JOIN vorgang_sachgebiet vs ON v.id = vs.vorgang_id
WHERE v.id = ?
`

type GetVorgangWithSachgebietRow struct {
	ID             string         `json:"id"`
	Titel          string         `json:"titel"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Typ            string         `json:"typ"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   string         `json:"aktualisiert"`
	Archiv         sql.NullString `json:"archiv"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullString `json:"datum"`
	Gesta          sql.NullString `json:"gesta"`
	Kom            sql.NullString `json:"kom"`
	Mitteilung     sql.NullString `json:"mitteilung"`
	Ratsdok        sql.NullString `json:"ratsdok"`
	Sek            sql.NullString `json:"sek"`
	Wahlperiode    int64          `json:"wahlperiode"`
	CreatedAt      string         `json:"created_at"`
	UpdatedAt      string         `json:"updated_at"`
	Sachgebiet     sql.NullString `json:"sachgebiet"`
}

func (q *Queries) GetVorgangWithSachgebiet(ctx context.Context, id string) ([]GetVorgangWithSachgebietRow, error) {
	rows, err := q.db.QueryContext(ctx, getVorgangWithSachgebiet, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVorgangWithSachgebietRow
	for rows.Next() {
		var i GetVorgangWithSachgebietRow
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Abstract,
			&i.Aktualisiert,
			&i.Archiv,
			&i.Beratungsstand,
			&i.Datum,
			&i.Gesta,
			&i.Kom,
			&i.Mitteilung,
			&i.Ratsdok,
			&i.Sek,
			&i.Wahlperiode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Sachgebiet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVorgaenge = `-- name: ListVorgaenge :many
SELECT id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
FROM vorgang
WHERE 
    (? IS NULL OR aktualisiert >= ?)
    AND (? IS NULL OR aktualisiert <= ?)
    AND (? IS NULL OR datum >= ?)
    AND (? IS NULL OR datum <= ?)
    AND (? IS NULL OR wahlperiode = ?)
    AND (? IS NULL OR vorgangstyp = ?)
    AND (? IS NULL OR gesta = ?)
ORDER BY aktualisiert DESC
LIMIT ? OFFSET ?
`

type ListVorgaengeParams struct {
	Column1        interface{}    `json:"column_1"`
	Aktualisiert   string         `json:"aktualisiert"`
	Column3        interface{}    `json:"column_3"`
	Aktualisiert_2 string         `json:"aktualisiert_2"`
	Column5        interface{}    `json:"column_5"`
	Datum          sql.NullString `json:"datum"`
	Column7        interface{}    `json:"column_7"`
	Datum_2        sql.NullString `json:"datum_2"`
	Column9        interface{}    `json:"column_9"`
	Wahlperiode    int64          `json:"wahlperiode"`
	Column11       interface{}    `json:"column_11"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Column13       interface{}    `json:"column_13"`
	Gesta          sql.NullString `json:"gesta"`
	Limit          int64          `json:"limit"`
	Offset         int64          `json:"offset"`
}

func (q *Queries) ListVorgaenge(ctx context.Context, arg ListVorgaengeParams) ([]Vorgang, error) {
	rows, err := q.db.QueryContext(ctx, listVorgaenge,
		arg.Column1,
		arg.Aktualisiert,
		arg.Column3,
		arg.Aktualisiert_2,
		arg.Column5,
		arg.Datum,
		arg.Column7,
		arg.Datum_2,
		arg.Column9,
		arg.Wahlperiode,
		arg.Column11,
		arg.Vorgangstyp,
		arg.Column13,
		arg.Gesta,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vorgang
	for rows.Next() {
		var i Vorgang
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Abstract,
			&i.Aktualisiert,
			&i.Archiv,
			&i.Beratungsstand,
			&i.Datum,
			&i.Gesta,
			&i.Kom,
			&i.Mitteilung,
			&i.Ratsdok,
			&i.Sek,
			&i.Wahlperiode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVorgang = `-- name: UpdateVorgang :one
UPDATE vorgang
SET 
    titel = ?,
    abstract = ?,
    aktualisiert = ?,
    beratungsstand = ?,
    datum = ?,
    mitteilung = ?,
    updated_at = datetime('now')
WHERE id = ?
RETURNING id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
`

type UpdateVorgangParams struct {
	Titel          string         `json:"titel"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   string         `json:"aktualisiert"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullString `json:"datum"`
	Mitteilung     sql.NullString `json:"mitteilung"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateVorgang(ctx context.Context, arg UpdateVorgangParams) (Vorgang, error) {
	row := q.db.QueryRowContext(ctx, updateVorgang,
		arg.Titel,
		arg.Abstract,
		arg.Aktualisiert,
		arg.Beratungsstand,
		arg.Datum,
		arg.Mitteilung,
		arg.ID,
	)
	var i Vorgang
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
