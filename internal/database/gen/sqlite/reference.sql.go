// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reference.sql

package db

import (
	"context"
	"database/sql"
)

const createFundstelleUrheber = `-- name: CreateFundstelleUrheber :one
INSERT INTO fundstelle_urheber (drucksache_id, plenarprotokoll_id, urheber)
VALUES (?, ?, ?)
RETURNING id, drucksache_id, plenarprotokoll_id, urheber, created_at
`

type CreateFundstelleUrheberParams struct {
	DrucksacheID      sql.NullString `json:"drucksache_id"`
	PlenarprotokollID sql.NullString `json:"plenarprotokoll_id"`
	Urheber           string         `json:"urheber"`
}

func (q *Queries) CreateFundstelleUrheber(ctx context.Context, arg CreateFundstelleUrheberParams) (FundstelleUrheber, error) {
	row := q.db.QueryRowContext(ctx, createFundstelleUrheber, arg.DrucksacheID, arg.PlenarprotokollID, arg.Urheber)
	var i FundstelleUrheber
	err := row.Scan(
		&i.ID,
		&i.DrucksacheID,
		&i.PlenarprotokollID,
		&i.Urheber,
		&i.CreatedAt,
	)
	return i, err
}

const getFundstelleUrheberByDrucksache = `-- name: GetFundstelleUrheberByDrucksache :many
SELECT id, drucksache_id, plenarprotokoll_id, urheber, created_at FROM fundstelle_urheber
WHERE drucksache_id = ?
`

func (q *Queries) GetFundstelleUrheberByDrucksache(ctx context.Context, drucksacheID sql.NullString) ([]FundstelleUrheber, error) {
	rows, err := q.db.QueryContext(ctx, getFundstelleUrheberByDrucksache, drucksacheID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundstelleUrheber
	for rows.Next() {
		var i FundstelleUrheber
		if err := rows.Scan(
			&i.ID,
			&i.DrucksacheID,
			&i.PlenarprotokollID,
			&i.Urheber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFundstelleUrheberByPlenarprotokoll = `-- name: GetFundstelleUrheberByPlenarprotokoll :many
SELECT id, drucksache_id, plenarprotokoll_id, urheber, created_at FROM fundstelle_urheber
WHERE plenarprotokoll_id = ?
`

func (q *Queries) GetFundstelleUrheberByPlenarprotokoll(ctx context.Context, plenarprotokollID sql.NullString) ([]FundstelleUrheber, error) {
	rows, err := q.db.QueryContext(ctx, getFundstelleUrheberByPlenarprotokoll, plenarprotokollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FundstelleUrheber
	for rows.Next() {
		var i FundstelleUrheber
		if err := rows.Scan(
			&i.ID,
			&i.DrucksacheID,
			&i.PlenarprotokollID,
			&i.Urheber,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrCreateBundesland = `-- name: GetOrCreateBundesland :one
INSERT INTO bundesland (name)
VALUES (?)
ON CONFLICT (name) DO NOTHING
RETURNING name, created_at
`

func (q *Queries) GetOrCreateBundesland(ctx context.Context, name string) (Bundesland, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateBundesland, name)
	var i Bundesland
	err := row.Scan(&i.Name, &i.CreatedAt)
	return i, err
}

const getOrCreateRessort = `-- name: GetOrCreateRessort :one
INSERT INTO ressort (titel)
VALUES (?)
ON CONFLICT (titel) DO UPDATE
SET titel = excluded.titel
RETURNING id, titel, created_at
`

func (q *Queries) GetOrCreateRessort(ctx context.Context, titel string) (Ressort, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateRessort, titel)
	var i Ressort
	err := row.Scan(&i.ID, &i.Titel, &i.CreatedAt)
	return i, err
}

const getOrCreateUrheber = `-- name: GetOrCreateUrheber :one
INSERT INTO urheber (bezeichnung, titel)
VALUES (?, ?)
ON CONFLICT (bezeichnung, titel) DO UPDATE
SET bezeichnung = excluded.bezeichnung
RETURNING id, bezeichnung, titel
`

type GetOrCreateUrheberParams struct {
	Bezeichnung string `json:"bezeichnung"`
	Titel       string `json:"titel"`
}

func (q *Queries) GetOrCreateUrheber(ctx context.Context, arg GetOrCreateUrheberParams) (Urheber, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateUrheber, arg.Bezeichnung, arg.Titel)
	var i Urheber
	err := row.Scan(&i.ID, &i.Bezeichnung, &i.Titel)
	return i, err
}

const getOrCreateWahlperiode = `-- name: GetOrCreateWahlperiode :one
INSERT INTO wahlperiode (nummer)
VALUES (?)
ON CONFLICT (nummer) DO UPDATE
SET updated_at = datetime('now')
RETURNING nummer, created_at, updated_at
`

func (q *Queries) GetOrCreateWahlperiode(ctx context.Context, nummer int64) (Wahlperiode, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateWahlperiode, nummer)
	var i Wahlperiode
	err := row.Scan(&i.Nummer, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getRessortByTitle = `-- name: GetRessortByTitle :one
SELECT id, titel, created_at FROM ressort
WHERE titel = ?
`

func (q *Queries) GetRessortByTitle(ctx context.Context, titel string) (Ressort, error) {
	row := q.db.QueryRowContext(ctx, getRessortByTitle, titel)
	var i Ressort
	err := row.Scan(&i.ID, &i.Titel, &i.CreatedAt)
	return i, err
}

const getUrheberByDesignationAndTitle = `-- name: GetUrheberByDesignationAndTitle :one
SELECT id, bezeichnung, titel FROM urheber
WHERE bezeichnung = ? AND titel = ?
`

type GetUrheberByDesignationAndTitleParams struct {
	Bezeichnung string `json:"bezeichnung"`
	Titel       string `json:"titel"`
}

func (q *Queries) GetUrheberByDesignationAndTitle(ctx context.Context, arg GetUrheberByDesignationAndTitleParams) (Urheber, error) {
	row := q.db.QueryRowContext(ctx, getUrheberByDesignationAndTitle, arg.Bezeichnung, arg.Titel)
	var i Urheber
	err := row.Scan(&i.ID, &i.Bezeichnung, &i.Titel)
	return i, err
}

const listBundeslaender = `-- name: ListBundeslaender :many
SELECT name, created_at FROM bundesland
ORDER BY name
`

func (q *Queries) ListBundeslaender(ctx context.Context) ([]Bundesland, error) {
	rows, err := q.db.QueryContext(ctx, listBundeslaender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bundesland
	for rows.Next() {
		var i Bundesland
		if err := rows.Scan(&i.Name, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRessorts = `-- name: ListRessorts :many
SELECT id, titel, created_at FROM ressort
ORDER BY titel
`

func (q *Queries) ListRessorts(ctx context.Context) ([]Ressort, error) {
	rows, err := q.db.QueryContext(ctx, listRessorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ressort
	for rows.Next() {
		var i Ressort
		if err := rows.Scan(&i.ID, &i.Titel, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUrheber = `-- name: ListUrheber :many
SELECT id, bezeichnung, titel FROM urheber
ORDER BY titel
`

func (q *Queries) ListUrheber(ctx context.Context) ([]Urheber, error) {
	rows, err := q.db.QueryContext(ctx, listUrheber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Urheber
	for rows.Next() {
		var i Urheber
		if err := rows.Scan(&i.ID, &i.Bezeichnung, &i.Titel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWahlperioden = `-- name: ListWahlperioden :many
SELECT nummer, created_at, updated_at FROM wahlperiode
ORDER BY nummer DESC
`

func (q *Queries) ListWahlperioden(ctx context.Context) ([]Wahlperiode, error) {
	rows, err := q.db.QueryContext(ctx, listWahlperioden)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wahlperiode
	for rows.Next() {
		var i Wahlperiode
		if err := rows.Scan(&i.Nummer, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
