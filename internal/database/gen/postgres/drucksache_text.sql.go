// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: drucksache_text.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countDrucksacheTexte = `-- name: CountDrucksacheTexte :one
SELECT COUNT(*) FROM drucksache d
INNER JOIN drucksache_text dt ON d.id = dt.id
WHERE 
    ($1::timestamptz IS NULL OR d.aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR d.aktualisiert <= $2)
    AND ($3::date IS NULL OR d.datum >= $3)
    AND ($4::date IS NULL OR d.datum <= $4)
    AND ($5::int IS NULL OR d.wahlperiode = $5)
    AND ($6::text IS NULL OR d.dokumentnummer = $6)
    AND ($7::text IS NULL OR d.drucksachetyp = $7)
`

type CountDrucksacheTexteParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 int32     `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
}

func (q *Queries) CountDrucksacheTexte(ctx context.Context, arg CountDrucksacheTexteParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDrucksacheTexte,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDrucksacheText = `-- name: CreateDrucksacheText :one
INSERT INTO drucksache_text (id, text)
VALUES ($1, $2)
ON CONFLICT (id) DO UPDATE
SET text = EXCLUDED.text,
    updated_at = NOW()
RETURNING id, text, created_at, updated_at
`

type CreateDrucksacheTextParams struct {
	ID   string         `json:"id"`
	Text sql.NullString `json:"text"`
}

func (q *Queries) CreateDrucksacheText(ctx context.Context, arg CreateDrucksacheTextParams) (DrucksacheText, error) {
	row := q.db.QueryRowContext(ctx, createDrucksacheText, arg.ID, arg.Text)
	var i DrucksacheText
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDrucksacheText = `-- name: DeleteDrucksacheText :exec
DELETE FROM drucksache_text WHERE id = $1
`

func (q *Queries) DeleteDrucksacheText(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDrucksacheText, id)
	return err
}

const getDrucksacheText = `-- name: GetDrucksacheText :one
SELECT 
    d.id, d.titel, d.dokumentnummer, d.dokumentart, d.typ, d.drucksachetyp, d.herausgeber, d.datum, d.aktualisiert, d.anlagen, d.autoren_anzahl, d.vorgangsbezug_anzahl, d.pdf_hash, d.wahlperiode, d.fundstelle_dokumentnummer, d.fundstelle_datum, d.fundstelle_dokumentart, d.fundstelle_herausgeber, d.fundstelle_id, d.fundstelle_drucksachetyp, d.fundstelle_anlagen, d.fundstelle_anfangsseite, d.fundstelle_endseite, d.fundstelle_anfangsquadrant, d.fundstelle_endquadrant, d.fundstelle_seite, d.fundstelle_pdf_url, d.fundstelle_top, d.fundstelle_top_zusatz, d.fundstelle_frage_nummer, d.fundstelle_verteildatum, d.created_at, d.updated_at,
    dt.text,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', daa.person_id,
                'autor_titel', daa.autor_titel,
                'title', daa.title
            ) ORDER BY daa.display_order
        ) FILTER (WHERE daa.id IS NOT NULL),
        '[]'
    ) AS autoren_anzeige,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'titel', r.titel,
                'federfuehrend', dr.federfuehrend
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'
    ) AS ressort,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'bezeichnung', u.bezeichnung,
                'titel', u.titel,
                'rolle', du.rolle,
                'einbringer', du.einbringer
            )
        ) FILTER (WHERE u.id IS NOT NULL),
        '[]'
    ) AS urheber,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', dvb.vorgang_id,
                'titel', dvb.titel,
                'vorgangstyp', dvb.vorgangstyp
            ) ORDER BY dvb.display_order
        ) FILTER (WHERE dvb.vorgang_id IS NOT NULL),
        '[]'
    ) AS vorgangsbezug
FROM drucksache d
LEFT JOIN drucksache_text dt ON d.id = dt.id
LEFT JOIN drucksache_autor_anzeige daa ON d.id = daa.drucksache_id
LEFT JOIN drucksache_ressort dr ON d.id = dr.drucksache_id
LEFT JOIN ressort r ON dr.ressort_id = r.id
LEFT JOIN drucksache_urheber du ON d.id = du.drucksache_id
LEFT JOIN urheber u ON du.urheber_id = u.id
LEFT JOIN drucksache_vorgangsbezug dvb ON d.id = dvb.drucksache_id
WHERE d.id = $1
GROUP BY d.id, dt.id, dt.text
`

type GetDrucksacheTextRow struct {
	ID                        string         `json:"id"`
	Titel                     string         `json:"titel"`
	Dokumentnummer            string         `json:"dokumentnummer"`
	Dokumentart               string         `json:"dokumentart"`
	Typ                       string         `json:"typ"`
	Drucksachetyp             string         `json:"drucksachetyp"`
	Herausgeber               string         `json:"herausgeber"`
	Datum                     time.Time      `json:"datum"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Anlagen                   sql.NullString `json:"anlagen"`
	AutorenAnzahl             int32          `json:"autoren_anzahl"`
	VorgangsbezugAnzahl       int32          `json:"vorgangsbezug_anzahl"`
	PdfHash                   sql.NullString `json:"pdf_hash"`
	Wahlperiode               sql.NullInt32  `json:"wahlperiode"`
	FundstelleDokumentnummer  string         `json:"fundstelle_dokumentnummer"`
	FundstelleDatum           time.Time      `json:"fundstelle_datum"`
	FundstelleDokumentart     string         `json:"fundstelle_dokumentart"`
	FundstelleHerausgeber     string         `json:"fundstelle_herausgeber"`
	FundstelleID              string         `json:"fundstelle_id"`
	FundstelleDrucksachetyp   sql.NullString `json:"fundstelle_drucksachetyp"`
	FundstelleAnlagen         sql.NullString `json:"fundstelle_anlagen"`
	FundstelleAnfangsseite    sql.NullInt32  `json:"fundstelle_anfangsseite"`
	FundstelleEndseite        sql.NullInt32  `json:"fundstelle_endseite"`
	FundstelleAnfangsquadrant sql.NullString `json:"fundstelle_anfangsquadrant"`
	FundstelleEndquadrant     sql.NullString `json:"fundstelle_endquadrant"`
	FundstelleSeite           sql.NullString `json:"fundstelle_seite"`
	FundstellePdfUrl          sql.NullString `json:"fundstelle_pdf_url"`
	FundstelleTop             sql.NullInt32  `json:"fundstelle_top"`
	FundstelleTopZusatz       sql.NullString `json:"fundstelle_top_zusatz"`
	FundstelleFrageNummer     sql.NullString `json:"fundstelle_frage_nummer"`
	FundstelleVerteildatum    sql.NullTime   `json:"fundstelle_verteildatum"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Text                      sql.NullString `json:"text"`
	AutorenAnzeige            interface{}    `json:"autoren_anzeige"`
	Ressort                   interface{}    `json:"ressort"`
	Urheber                   interface{}    `json:"urheber"`
	Vorgangsbezug             interface{}    `json:"vorgangsbezug"`
}

func (q *Queries) GetDrucksacheText(ctx context.Context, id string) (GetDrucksacheTextRow, error) {
	row := q.db.QueryRowContext(ctx, getDrucksacheText, id)
	var i GetDrucksacheTextRow
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Dokumentnummer,
		&i.Dokumentart,
		&i.Typ,
		&i.Drucksachetyp,
		&i.Herausgeber,
		&i.Datum,
		&i.Aktualisiert,
		&i.Anlagen,
		&i.AutorenAnzahl,
		&i.VorgangsbezugAnzahl,
		&i.PdfHash,
		&i.Wahlperiode,
		&i.FundstelleDokumentnummer,
		&i.FundstelleDatum,
		&i.FundstelleDokumentart,
		&i.FundstelleHerausgeber,
		&i.FundstelleID,
		&i.FundstelleDrucksachetyp,
		&i.FundstelleAnlagen,
		&i.FundstelleAnfangsseite,
		&i.FundstelleEndseite,
		&i.FundstelleAnfangsquadrant,
		&i.FundstelleEndquadrant,
		&i.FundstelleSeite,
		&i.FundstellePdfUrl,
		&i.FundstelleTop,
		&i.FundstelleTopZusatz,
		&i.FundstelleFrageNummer,
		&i.FundstelleVerteildatum,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Text,
		&i.AutorenAnzeige,
		&i.Ressort,
		&i.Urheber,
		&i.Vorgangsbezug,
	)
	return i, err
}

const listDrucksacheTexte = `-- name: ListDrucksacheTexte :many
SELECT 
    d.id, d.titel, d.dokumentnummer, d.dokumentart, d.typ, d.drucksachetyp, d.herausgeber, d.datum, d.aktualisiert, d.anlagen, d.autoren_anzahl, d.vorgangsbezug_anzahl, d.pdf_hash, d.wahlperiode, d.fundstelle_dokumentnummer, d.fundstelle_datum, d.fundstelle_dokumentart, d.fundstelle_herausgeber, d.fundstelle_id, d.fundstelle_drucksachetyp, d.fundstelle_anlagen, d.fundstelle_anfangsseite, d.fundstelle_endseite, d.fundstelle_anfangsquadrant, d.fundstelle_endquadrant, d.fundstelle_seite, d.fundstelle_pdf_url, d.fundstelle_top, d.fundstelle_top_zusatz, d.fundstelle_frage_nummer, d.fundstelle_verteildatum, d.created_at, d.updated_at,
    dt.text,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', daa.person_id,
                'autor_titel', daa.autor_titel,
                'title', daa.title
            ) ORDER BY daa.display_order
        ) FILTER (WHERE daa.id IS NOT NULL),
        '[]'
    ) AS autoren_anzeige,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'titel', r.titel,
                'federfuehrend', dr.federfuehrend
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'
    ) AS ressort,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'bezeichnung', u.bezeichnung,
                'titel', u.titel,
                'rolle', du.rolle,
                'einbringer', du.einbringer
            )
        ) FILTER (WHERE u.id IS NOT NULL),
        '[]'
    ) AS urheber,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', dvb.vorgang_id,
                'titel', dvb.titel,
                'vorgangstyp', dvb.vorgangstyp
            ) ORDER BY dvb.display_order
        ) FILTER (WHERE dvb.vorgang_id IS NOT NULL),
        '[]'
    ) AS vorgangsbezug
FROM drucksache d
INNER JOIN drucksache_text dt ON d.id = dt.id
LEFT JOIN drucksache_autor_anzeige daa ON d.id = daa.drucksache_id
LEFT JOIN drucksache_ressort dr ON d.id = dr.drucksache_id
LEFT JOIN ressort r ON dr.ressort_id = r.id
LEFT JOIN drucksache_urheber du ON d.id = du.drucksache_id
LEFT JOIN urheber u ON du.urheber_id = u.id
LEFT JOIN drucksache_vorgangsbezug dvb ON d.id = dvb.drucksache_id
WHERE 
    ($1::timestamptz IS NULL OR d.aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR d.aktualisiert <= $2)
    AND ($3::date IS NULL OR d.datum >= $3)
    AND ($4::date IS NULL OR d.datum <= $4)
    AND ($5::int IS NULL OR d.wahlperiode = $5)
    AND ($6::text IS NULL OR d.dokumentnummer = $6)
    AND ($7::text IS NULL OR d.drucksachetyp = $7)
GROUP BY d.id, dt.id, dt.text
ORDER BY d.aktualisiert DESC
LIMIT $8 OFFSET $9
`

type ListDrucksacheTexteParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 int32     `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListDrucksacheTexteRow struct {
	ID                        string         `json:"id"`
	Titel                     string         `json:"titel"`
	Dokumentnummer            string         `json:"dokumentnummer"`
	Dokumentart               string         `json:"dokumentart"`
	Typ                       string         `json:"typ"`
	Drucksachetyp             string         `json:"drucksachetyp"`
	Herausgeber               string         `json:"herausgeber"`
	Datum                     time.Time      `json:"datum"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Anlagen                   sql.NullString `json:"anlagen"`
	AutorenAnzahl             int32          `json:"autoren_anzahl"`
	VorgangsbezugAnzahl       int32          `json:"vorgangsbezug_anzahl"`
	PdfHash                   sql.NullString `json:"pdf_hash"`
	Wahlperiode               sql.NullInt32  `json:"wahlperiode"`
	FundstelleDokumentnummer  string         `json:"fundstelle_dokumentnummer"`
	FundstelleDatum           time.Time      `json:"fundstelle_datum"`
	FundstelleDokumentart     string         `json:"fundstelle_dokumentart"`
	FundstelleHerausgeber     string         `json:"fundstelle_herausgeber"`
	FundstelleID              string         `json:"fundstelle_id"`
	FundstelleDrucksachetyp   sql.NullString `json:"fundstelle_drucksachetyp"`
	FundstelleAnlagen         sql.NullString `json:"fundstelle_anlagen"`
	FundstelleAnfangsseite    sql.NullInt32  `json:"fundstelle_anfangsseite"`
	FundstelleEndseite        sql.NullInt32  `json:"fundstelle_endseite"`
	FundstelleAnfangsquadrant sql.NullString `json:"fundstelle_anfangsquadrant"`
	FundstelleEndquadrant     sql.NullString `json:"fundstelle_endquadrant"`
	FundstelleSeite           sql.NullString `json:"fundstelle_seite"`
	FundstellePdfUrl          sql.NullString `json:"fundstelle_pdf_url"`
	FundstelleTop             sql.NullInt32  `json:"fundstelle_top"`
	FundstelleTopZusatz       sql.NullString `json:"fundstelle_top_zusatz"`
	FundstelleFrageNummer     sql.NullString `json:"fundstelle_frage_nummer"`
	FundstelleVerteildatum    sql.NullTime   `json:"fundstelle_verteildatum"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Text                      sql.NullString `json:"text"`
	AutorenAnzeige            interface{}    `json:"autoren_anzeige"`
	Ressort                   interface{}    `json:"ressort"`
	Urheber                   interface{}    `json:"urheber"`
	Vorgangsbezug             interface{}    `json:"vorgangsbezug"`
}

func (q *Queries) ListDrucksacheTexte(ctx context.Context, arg ListDrucksacheTexteParams) ([]ListDrucksacheTexteRow, error) {
	rows, err := q.db.QueryContext(ctx, listDrucksacheTexte,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDrucksacheTexteRow
	for rows.Next() {
		var i ListDrucksacheTexteRow
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Dokumentnummer,
			&i.Dokumentart,
			&i.Typ,
			&i.Drucksachetyp,
			&i.Herausgeber,
			&i.Datum,
			&i.Aktualisiert,
			&i.Anlagen,
			&i.AutorenAnzahl,
			&i.VorgangsbezugAnzahl,
			&i.PdfHash,
			&i.Wahlperiode,
			&i.FundstelleDokumentnummer,
			&i.FundstelleDatum,
			&i.FundstelleDokumentart,
			&i.FundstelleHerausgeber,
			&i.FundstelleID,
			&i.FundstelleDrucksachetyp,
			&i.FundstelleAnlagen,
			&i.FundstelleAnfangsseite,
			&i.FundstelleEndseite,
			&i.FundstelleAnfangsquadrant,
			&i.FundstelleEndquadrant,
			&i.FundstelleSeite,
			&i.FundstellePdfUrl,
			&i.FundstelleTop,
			&i.FundstelleTopZusatz,
			&i.FundstelleFrageNummer,
			&i.FundstelleVerteildatum,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Text,
			&i.AutorenAnzeige,
			&i.Ressort,
			&i.Urheber,
			&i.Vorgangsbezug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDrucksacheText = `-- name: UpdateDrucksacheText :one
UPDATE drucksache_text
SET text = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, text, created_at, updated_at
`

type UpdateDrucksacheTextParams struct {
	ID   string         `json:"id"`
	Text sql.NullString `json:"text"`
}

func (q *Queries) UpdateDrucksacheText(ctx context.Context, arg UpdateDrucksacheTextParams) (DrucksacheText, error) {
	row := q.db.QueryRowContext(ctx, updateDrucksacheText, arg.ID, arg.Text)
	var i DrucksacheText
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
