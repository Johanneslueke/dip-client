// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vorgang.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countVorgaenge = `-- name: CountVorgaenge :one
SELECT COUNT(*) FROM vorgang
WHERE 
    ($1::timestamptz IS NULL OR aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR aktualisiert <= $2)
    AND ($3::date IS NULL OR datum >= $3)
    AND ($4::date IS NULL OR datum <= $4)
    AND ($5::int IS NULL OR wahlperiode = $5)
    AND ($6::text IS NULL OR vorgangstyp = $6)
    AND ($7::text IS NULL OR gesta = $7)
`

type CountVorgaengeParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 int32     `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
}

func (q *Queries) CountVorgaenge(ctx context.Context, arg CountVorgaengeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVorgaenge,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInkrafttreten = `-- name: CreateInkrafttreten :one
INSERT INTO inkrafttreten (vorgang_id, datum, erlaeuterung)
VALUES ($1, $2, $3)
RETURNING id, vorgang_id, datum, erlaeuterung, created_at
`

type CreateInkrafttretenParams struct {
	VorgangID    string         `json:"vorgang_id"`
	Datum        time.Time      `json:"datum"`
	Erlaeuterung sql.NullString `json:"erlaeuterung"`
}

func (q *Queries) CreateInkrafttreten(ctx context.Context, arg CreateInkrafttretenParams) (Inkrafttreten, error) {
	row := q.db.QueryRowContext(ctx, createInkrafttreten, arg.VorgangID, arg.Datum, arg.Erlaeuterung)
	var i Inkrafttreten
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Datum,
		&i.Erlaeuterung,
		&i.CreatedAt,
	)
	return i, err
}

const createVerkuendung = `-- name: CreateVerkuendung :one
INSERT INTO verkuendung (
    vorgang_id, ausfertigungsdatum, verkuendungsdatum, einleitungstext,
    fundstelle, jahrgang, seite, heftnummer, pdf_url, rubrik_nr,
    titel, verkuendungsblatt_bezeichnung, verkuendungsblatt_kuerzel
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, vorgang_id, ausfertigungsdatum, verkuendungsdatum, einleitungstext, fundstelle, jahrgang, seite, heftnummer, pdf_url, rubrik_nr, titel, verkuendungsblatt_bezeichnung, verkuendungsblatt_kuerzel, created_at
`

type CreateVerkuendungParams struct {
	VorgangID                    string         `json:"vorgang_id"`
	Ausfertigungsdatum           time.Time      `json:"ausfertigungsdatum"`
	Verkuendungsdatum            time.Time      `json:"verkuendungsdatum"`
	Einleitungstext              string         `json:"einleitungstext"`
	Fundstelle                   string         `json:"fundstelle"`
	Jahrgang                     string         `json:"jahrgang"`
	Seite                        string         `json:"seite"`
	Heftnummer                   sql.NullString `json:"heftnummer"`
	PdfUrl                       sql.NullString `json:"pdf_url"`
	RubrikNr                     sql.NullString `json:"rubrik_nr"`
	Titel                        sql.NullString `json:"titel"`
	VerkuendungsblattBezeichnung sql.NullString `json:"verkuendungsblatt_bezeichnung"`
	VerkuendungsblattKuerzel     sql.NullString `json:"verkuendungsblatt_kuerzel"`
}

func (q *Queries) CreateVerkuendung(ctx context.Context, arg CreateVerkuendungParams) (Verkuendung, error) {
	row := q.db.QueryRowContext(ctx, createVerkuendung,
		arg.VorgangID,
		arg.Ausfertigungsdatum,
		arg.Verkuendungsdatum,
		arg.Einleitungstext,
		arg.Fundstelle,
		arg.Jahrgang,
		arg.Seite,
		arg.Heftnummer,
		arg.PdfUrl,
		arg.RubrikNr,
		arg.Titel,
		arg.VerkuendungsblattBezeichnung,
		arg.VerkuendungsblattKuerzel,
	)
	var i Verkuendung
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Ausfertigungsdatum,
		&i.Verkuendungsdatum,
		&i.Einleitungstext,
		&i.Fundstelle,
		&i.Jahrgang,
		&i.Seite,
		&i.Heftnummer,
		&i.PdfUrl,
		&i.RubrikNr,
		&i.Titel,
		&i.VerkuendungsblattBezeichnung,
		&i.VerkuendungsblattKuerzel,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgang = `-- name: CreateVorgang :one
INSERT INTO vorgang (
    id, titel, vorgangstyp, typ, abstract, aktualisiert,
    archiv, beratungsstand, datum, gesta, kom, mitteilung,
    ratsdok, sek, wahlperiode
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
RETURNING id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
`

type CreateVorgangParams struct {
	ID             string         `json:"id"`
	Titel          string         `json:"titel"`
	Vorgangstyp    string         `json:"vorgangstyp"`
	Typ            string         `json:"typ"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   time.Time      `json:"aktualisiert"`
	Archiv         sql.NullString `json:"archiv"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullTime   `json:"datum"`
	Gesta          sql.NullString `json:"gesta"`
	Kom            sql.NullString `json:"kom"`
	Mitteilung     sql.NullString `json:"mitteilung"`
	Ratsdok        sql.NullString `json:"ratsdok"`
	Sek            sql.NullString `json:"sek"`
	Wahlperiode    int32          `json:"wahlperiode"`
}

func (q *Queries) CreateVorgang(ctx context.Context, arg CreateVorgangParams) (Vorgang, error) {
	row := q.db.QueryRowContext(ctx, createVorgang,
		arg.ID,
		arg.Titel,
		arg.Vorgangstyp,
		arg.Typ,
		arg.Abstract,
		arg.Aktualisiert,
		arg.Archiv,
		arg.Beratungsstand,
		arg.Datum,
		arg.Gesta,
		arg.Kom,
		arg.Mitteilung,
		arg.Ratsdok,
		arg.Sek,
		arg.Wahlperiode,
	)
	var i Vorgang
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVorgangDeskriptor = `-- name: CreateVorgangDeskriptor :one
INSERT INTO vorgang_deskriptor (vorgang_id, name, typ, fundstelle)
VALUES ($1, $2, $3, $4)
ON CONFLICT (vorgang_id, name, typ) DO UPDATE
SET fundstelle = EXCLUDED.fundstelle
RETURNING id, vorgang_id, name, typ, fundstelle, created_at
`

type CreateVorgangDeskriptorParams struct {
	VorgangID  string `json:"vorgang_id"`
	Name       string `json:"name"`
	Typ        string `json:"typ"`
	Fundstelle bool   `json:"fundstelle"`
}

func (q *Queries) CreateVorgangDeskriptor(ctx context.Context, arg CreateVorgangDeskriptorParams) (VorgangDeskriptor, error) {
	row := q.db.QueryRowContext(ctx, createVorgangDeskriptor,
		arg.VorgangID,
		arg.Name,
		arg.Typ,
		arg.Fundstelle,
	)
	var i VorgangDeskriptor
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Name,
		&i.Typ,
		&i.Fundstelle,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgangInitiative = `-- name: CreateVorgangInitiative :exec
INSERT INTO vorgang_initiative (vorgang_id, initiative)
VALUES ($1, $2)
`

type CreateVorgangInitiativeParams struct {
	VorgangID  string `json:"vorgang_id"`
	Initiative string `json:"initiative"`
}

func (q *Queries) CreateVorgangInitiative(ctx context.Context, arg CreateVorgangInitiativeParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangInitiative, arg.VorgangID, arg.Initiative)
	return err
}

const createVorgangSachgebiet = `-- name: CreateVorgangSachgebiet :exec
INSERT INTO vorgang_sachgebiet (vorgang_id, sachgebiet)
VALUES ($1, $2)
`

type CreateVorgangSachgebietParams struct {
	VorgangID  string `json:"vorgang_id"`
	Sachgebiet string `json:"sachgebiet"`
}

func (q *Queries) CreateVorgangSachgebiet(ctx context.Context, arg CreateVorgangSachgebietParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangSachgebiet, arg.VorgangID, arg.Sachgebiet)
	return err
}

const createVorgangVerlinkung = `-- name: CreateVorgangVerlinkung :one
INSERT INTO vorgang_verlinkung (
    source_vorgang_id, target_vorgang_id, titel, verweisung, gesta, wahlperiode
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (source_vorgang_id, target_vorgang_id) DO UPDATE
SET titel = EXCLUDED.titel,
    verweisung = EXCLUDED.verweisung,
    gesta = EXCLUDED.gesta,
    wahlperiode = EXCLUDED.wahlperiode
RETURNING id, source_vorgang_id, target_vorgang_id, titel, verweisung, gesta, wahlperiode, created_at
`

type CreateVorgangVerlinkungParams struct {
	SourceVorgangID string         `json:"source_vorgang_id"`
	TargetVorgangID string         `json:"target_vorgang_id"`
	Titel           string         `json:"titel"`
	Verweisung      string         `json:"verweisung"`
	Gesta           sql.NullString `json:"gesta"`
	Wahlperiode     int32          `json:"wahlperiode"`
}

func (q *Queries) CreateVorgangVerlinkung(ctx context.Context, arg CreateVorgangVerlinkungParams) (VorgangVerlinkung, error) {
	row := q.db.QueryRowContext(ctx, createVorgangVerlinkung,
		arg.SourceVorgangID,
		arg.TargetVorgangID,
		arg.Titel,
		arg.Verweisung,
		arg.Gesta,
		arg.Wahlperiode,
	)
	var i VorgangVerlinkung
	err := row.Scan(
		&i.ID,
		&i.SourceVorgangID,
		&i.TargetVorgangID,
		&i.Titel,
		&i.Verweisung,
		&i.Gesta,
		&i.Wahlperiode,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgangZustimmungsbeduerftigkeit = `-- name: CreateVorgangZustimmungsbeduerftigkeit :exec
INSERT INTO vorgang_zustimmungsbeduerftigkeit (vorgang_id, zustimmungsbeduerftigkeit)
VALUES ($1, $2)
`

type CreateVorgangZustimmungsbeduerftigkeitParams struct {
	VorgangID                 string `json:"vorgang_id"`
	Zustimmungsbeduerftigkeit string `json:"zustimmungsbeduerftigkeit"`
}

func (q *Queries) CreateVorgangZustimmungsbeduerftigkeit(ctx context.Context, arg CreateVorgangZustimmungsbeduerftigkeitParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangZustimmungsbeduerftigkeit, arg.VorgangID, arg.Zustimmungsbeduerftigkeit)
	return err
}

const deleteVorgang = `-- name: DeleteVorgang :exec
DELETE FROM vorgang WHERE id = $1
`

func (q *Queries) DeleteVorgang(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteVorgang, id)
	return err
}

const getVorgang = `-- name: GetVorgang :one
SELECT 
    v.id, v.titel, v.vorgangstyp, v.typ, v.abstract, v.aktualisiert, v.archiv, v.beratungsstand, v.datum, v.gesta, v.kom, v.mitteilung, v.ratsdok, v.sek, v.wahlperiode, v.created_at, v.updated_at,
    COALESCE(
        json_agg(DISTINCT vi.initiative) FILTER (WHERE vi.id IS NOT NULL),
        '[]'
    ) AS initiative,
    COALESCE(
        json_agg(DISTINCT vs.sachgebiet) FILTER (WHERE vs.id IS NOT NULL),
        '[]'
    ) AS sachgebiet,
    COALESCE(
        json_agg(DISTINCT vz.zustimmungsbeduerftigkeit) FILTER (WHERE vz.id IS NOT NULL),
        '[]'
    ) AS zustimmungsbeduerftigkeit,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'name', vd.name,
                'typ', vd.typ,
                'fundstelle', vd.fundstelle
            )
        ) FILTER (WHERE vd.id IS NOT NULL),
        '[]'
    ) AS deskriptor,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'ausfertigungsdatum', vk.ausfertigungsdatum,
                'verkuendungsdatum', vk.verkuendungsdatum,
                'einleitungstext', vk.einleitungstext,
                'fundstelle', vk.fundstelle,
                'jahrgang', vk.jahrgang,
                'seite', vk.seite,
                'heftnummer', vk.heftnummer,
                'pdf_url', vk.pdf_url,
                'rubrik_nr', vk.rubrik_nr,
                'titel', vk.titel,
                'verkuendungsblatt_bezeichnung', vk.verkuendungsblatt_bezeichnung,
                'verkuendungsblatt_kuerzel', vk.verkuendungsblatt_kuerzel
            )
        ) FILTER (WHERE vk.id IS NOT NULL),
        '[]'
    ) AS verkuendung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'datum', ik.datum,
                'erlaeuterung', ik.erlaeuterung
            )
        ) FILTER (WHERE ik.id IS NOT NULL),
        '[]'
    ) AS inkrafttreten,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', vvl.target_vorgang_id,
                'titel', vvl.titel,
                'verweisung', vvl.verweisung,
                'gesta', vvl.gesta,
                'wahlperiode', vvl.wahlperiode
            )
        ) FILTER (WHERE vvl.id IS NOT NULL),
        '[]'
    ) AS vorgang_verlinkung
FROM vorgang v
LEFT JOIN vorgang_initiative vi ON v.id = vi.vorgang_id
LEFT JOIN vorgang_sachgebiet vs ON v.id = vs.vorgang_id
LEFT JOIN vorgang_zustimmungsbeduerftigkeit vz ON v.id = vz.vorgang_id
LEFT JOIN vorgang_deskriptor vd ON v.id = vd.vorgang_id
LEFT JOIN verkuendung vk ON v.id = vk.vorgang_id
LEFT JOIN inkrafttreten ik ON v.id = ik.vorgang_id
LEFT JOIN vorgang_verlinkung vvl ON v.id = vvl.source_vorgang_id
WHERE v.id = $1
GROUP BY v.id
`

type GetVorgangRow struct {
	ID                        string         `json:"id"`
	Titel                     string         `json:"titel"`
	Vorgangstyp               string         `json:"vorgangstyp"`
	Typ                       string         `json:"typ"`
	Abstract                  sql.NullString `json:"abstract"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Archiv                    sql.NullString `json:"archiv"`
	Beratungsstand            sql.NullString `json:"beratungsstand"`
	Datum                     sql.NullTime   `json:"datum"`
	Gesta                     sql.NullString `json:"gesta"`
	Kom                       sql.NullString `json:"kom"`
	Mitteilung                sql.NullString `json:"mitteilung"`
	Ratsdok                   sql.NullString `json:"ratsdok"`
	Sek                       sql.NullString `json:"sek"`
	Wahlperiode               int32          `json:"wahlperiode"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Initiative                interface{}    `json:"initiative"`
	Sachgebiet                interface{}    `json:"sachgebiet"`
	Zustimmungsbeduerftigkeit interface{}    `json:"zustimmungsbeduerftigkeit"`
	Deskriptor                interface{}    `json:"deskriptor"`
	Verkuendung               interface{}    `json:"verkuendung"`
	Inkrafttreten             interface{}    `json:"inkrafttreten"`
	VorgangVerlinkung         interface{}    `json:"vorgang_verlinkung"`
}

func (q *Queries) GetVorgang(ctx context.Context, id string) (GetVorgangRow, error) {
	row := q.db.QueryRowContext(ctx, getVorgang, id)
	var i GetVorgangRow
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Initiative,
		&i.Sachgebiet,
		&i.Zustimmungsbeduerftigkeit,
		&i.Deskriptor,
		&i.Verkuendung,
		&i.Inkrafttreten,
		&i.VorgangVerlinkung,
	)
	return i, err
}

const listVorgaenge = `-- name: ListVorgaenge :many
SELECT 
    v.id, v.titel, v.vorgangstyp, v.typ, v.abstract, v.aktualisiert, v.archiv, v.beratungsstand, v.datum, v.gesta, v.kom, v.mitteilung, v.ratsdok, v.sek, v.wahlperiode, v.created_at, v.updated_at,
    COALESCE(
        json_agg(DISTINCT vi.initiative) FILTER (WHERE vi.id IS NOT NULL),
        '[]'
    ) AS initiative,
    COALESCE(
        json_agg(DISTINCT vs.sachgebiet) FILTER (WHERE vs.id IS NOT NULL),
        '[]'
    ) AS sachgebiet,
    COALESCE(
        json_agg(DISTINCT vz.zustimmungsbeduerftigkeit) FILTER (WHERE vz.id IS NOT NULL),
        '[]'
    ) AS zustimmungsbeduerftigkeit,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'name', vd.name,
                'typ', vd.typ,
                'fundstelle', vd.fundstelle
            )
        ) FILTER (WHERE vd.id IS NOT NULL),
        '[]'
    ) AS deskriptor,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'ausfertigungsdatum', vk.ausfertigungsdatum,
                'verkuendungsdatum', vk.verkuendungsdatum,
                'einleitungstext', vk.einleitungstext,
                'fundstelle', vk.fundstelle,
                'jahrgang', vk.jahrgang,
                'seite', vk.seite
            )
        ) FILTER (WHERE vk.id IS NOT NULL),
        '[]'
    ) AS verkuendung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'datum', ik.datum,
                'erlaeuterung', ik.erlaeuterung
            )
        ) FILTER (WHERE ik.id IS NOT NULL),
        '[]'
    ) AS inkrafttreten
FROM vorgang v
LEFT JOIN vorgang_initiative vi ON v.id = vi.vorgang_id
LEFT JOIN vorgang_sachgebiet vs ON v.id = vs.vorgang_id
LEFT JOIN vorgang_zustimmungsbeduerftigkeit vz ON v.id = vz.vorgang_id
LEFT JOIN vorgang_deskriptor vd ON v.id = vd.vorgang_id
LEFT JOIN verkuendung vk ON v.id = vk.vorgang_id
LEFT JOIN inkrafttreten ik ON v.id = ik.vorgang_id
WHERE 
    ($1::timestamptz IS NULL OR v.aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR v.aktualisiert <= $2)
    AND ($3::date IS NULL OR v.datum >= $3)
    AND ($4::date IS NULL OR v.datum <= $4)
    AND ($5::int IS NULL OR v.wahlperiode = $5)
    AND ($6::text IS NULL OR v.vorgangstyp = $6)
    AND ($7::text IS NULL OR v.gesta = $7)
GROUP BY v.id
ORDER BY v.aktualisiert DESC
LIMIT $8 OFFSET $9
`

type ListVorgaengeParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 int32     `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListVorgaengeRow struct {
	ID                        string         `json:"id"`
	Titel                     string         `json:"titel"`
	Vorgangstyp               string         `json:"vorgangstyp"`
	Typ                       string         `json:"typ"`
	Abstract                  sql.NullString `json:"abstract"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Archiv                    sql.NullString `json:"archiv"`
	Beratungsstand            sql.NullString `json:"beratungsstand"`
	Datum                     sql.NullTime   `json:"datum"`
	Gesta                     sql.NullString `json:"gesta"`
	Kom                       sql.NullString `json:"kom"`
	Mitteilung                sql.NullString `json:"mitteilung"`
	Ratsdok                   sql.NullString `json:"ratsdok"`
	Sek                       sql.NullString `json:"sek"`
	Wahlperiode               int32          `json:"wahlperiode"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Initiative                interface{}    `json:"initiative"`
	Sachgebiet                interface{}    `json:"sachgebiet"`
	Zustimmungsbeduerftigkeit interface{}    `json:"zustimmungsbeduerftigkeit"`
	Deskriptor                interface{}    `json:"deskriptor"`
	Verkuendung               interface{}    `json:"verkuendung"`
	Inkrafttreten             interface{}    `json:"inkrafttreten"`
}

func (q *Queries) ListVorgaenge(ctx context.Context, arg ListVorgaengeParams) ([]ListVorgaengeRow, error) {
	rows, err := q.db.QueryContext(ctx, listVorgaenge,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVorgaengeRow
	for rows.Next() {
		var i ListVorgaengeRow
		if err := rows.Scan(
			&i.ID,
			&i.Titel,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Abstract,
			&i.Aktualisiert,
			&i.Archiv,
			&i.Beratungsstand,
			&i.Datum,
			&i.Gesta,
			&i.Kom,
			&i.Mitteilung,
			&i.Ratsdok,
			&i.Sek,
			&i.Wahlperiode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Initiative,
			&i.Sachgebiet,
			&i.Zustimmungsbeduerftigkeit,
			&i.Deskriptor,
			&i.Verkuendung,
			&i.Inkrafttreten,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVorgang = `-- name: UpdateVorgang :one
UPDATE vorgang
SET 
    titel = $2,
    abstract = $3,
    aktualisiert = $4,
    beratungsstand = $5,
    datum = $6,
    mitteilung = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, titel, vorgangstyp, typ, abstract, aktualisiert, archiv, beratungsstand, datum, gesta, kom, mitteilung, ratsdok, sek, wahlperiode, created_at, updated_at
`

type UpdateVorgangParams struct {
	ID             string         `json:"id"`
	Titel          string         `json:"titel"`
	Abstract       sql.NullString `json:"abstract"`
	Aktualisiert   time.Time      `json:"aktualisiert"`
	Beratungsstand sql.NullString `json:"beratungsstand"`
	Datum          sql.NullTime   `json:"datum"`
	Mitteilung     sql.NullString `json:"mitteilung"`
}

func (q *Queries) UpdateVorgang(ctx context.Context, arg UpdateVorgangParams) (Vorgang, error) {
	row := q.db.QueryRowContext(ctx, updateVorgang,
		arg.ID,
		arg.Titel,
		arg.Abstract,
		arg.Aktualisiert,
		arg.Beratungsstand,
		arg.Datum,
		arg.Mitteilung,
	)
	var i Vorgang
	err := row.Scan(
		&i.ID,
		&i.Titel,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Abstract,
		&i.Aktualisiert,
		&i.Archiv,
		&i.Beratungsstand,
		&i.Datum,
		&i.Gesta,
		&i.Kom,
		&i.Mitteilung,
		&i.Ratsdok,
		&i.Sek,
		&i.Wahlperiode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
