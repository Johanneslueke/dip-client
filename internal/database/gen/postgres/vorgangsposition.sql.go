// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vorgangsposition.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countVorgangspositionen = `-- name: CountVorgangspositionen :one
SELECT COUNT(*) FROM vorgangsposition
WHERE 
    ($1::timestamptz IS NULL OR aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR aktualisiert <= $2)
    AND ($3::date IS NULL OR datum >= $3)
    AND ($4::date IS NULL OR datum <= $4)
    AND ($5::text IS NULL OR vorgang_id = $5)
    AND ($6::text IS NULL OR dokumentart = $6)
    AND ($7::text IS NULL OR fundstelle_dokumentnummer = $7)
    AND ($8::text IS NULL OR zuordnung = $8)
`

type CountVorgangspositionenParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 string    `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
	Column8 string    `json:"column_8"`
}

func (q *Queries) CountVorgangspositionen(ctx context.Context, arg CountVorgangspositionenParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVorgangspositionen,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAktivitaetAnzeige = `-- name: CreateAktivitaetAnzeige :one
INSERT INTO aktivitaet_anzeige (
    vorgangsposition_id, aktivitaetsart, titel, seite, pdf_url, display_order
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, vorgangsposition_id, aktivitaetsart, titel, seite, pdf_url, display_order, created_at
`

type CreateAktivitaetAnzeigeParams struct {
	VorgangspositionID string         `json:"vorgangsposition_id"`
	Aktivitaetsart     string         `json:"aktivitaetsart"`
	Titel              string         `json:"titel"`
	Seite              sql.NullString `json:"seite"`
	PdfUrl             sql.NullString `json:"pdf_url"`
	DisplayOrder       int32          `json:"display_order"`
}

func (q *Queries) CreateAktivitaetAnzeige(ctx context.Context, arg CreateAktivitaetAnzeigeParams) (AktivitaetAnzeige, error) {
	row := q.db.QueryRowContext(ctx, createAktivitaetAnzeige,
		arg.VorgangspositionID,
		arg.Aktivitaetsart,
		arg.Titel,
		arg.Seite,
		arg.PdfUrl,
		arg.DisplayOrder,
	)
	var i AktivitaetAnzeige
	err := row.Scan(
		&i.ID,
		&i.VorgangspositionID,
		&i.Aktivitaetsart,
		&i.Titel,
		&i.Seite,
		&i.PdfUrl,
		&i.DisplayOrder,
		&i.CreatedAt,
	)
	return i, err
}

const createBeschlussfassung = `-- name: CreateBeschlussfassung :one
INSERT INTO beschlussfassung (
    vorgangsposition_id, beschlusstenor, abstimmungsart, mehrheit,
    abstimm_ergebnis_bemerkung, dokumentnummer, grundlage, seite
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, vorgangsposition_id, beschlusstenor, abstimmungsart, mehrheit, abstimm_ergebnis_bemerkung, dokumentnummer, grundlage, seite, created_at
`

type CreateBeschlussfassungParams struct {
	VorgangspositionID       string         `json:"vorgangsposition_id"`
	Beschlusstenor           string         `json:"beschlusstenor"`
	Abstimmungsart           sql.NullString `json:"abstimmungsart"`
	Mehrheit                 sql.NullString `json:"mehrheit"`
	AbstimmErgebnisBemerkung sql.NullString `json:"abstimm_ergebnis_bemerkung"`
	Dokumentnummer           sql.NullString `json:"dokumentnummer"`
	Grundlage                sql.NullString `json:"grundlage"`
	Seite                    sql.NullString `json:"seite"`
}

func (q *Queries) CreateBeschlussfassung(ctx context.Context, arg CreateBeschlussfassungParams) (Beschlussfassung, error) {
	row := q.db.QueryRowContext(ctx, createBeschlussfassung,
		arg.VorgangspositionID,
		arg.Beschlusstenor,
		arg.Abstimmungsart,
		arg.Mehrheit,
		arg.AbstimmErgebnisBemerkung,
		arg.Dokumentnummer,
		arg.Grundlage,
		arg.Seite,
	)
	var i Beschlussfassung
	err := row.Scan(
		&i.ID,
		&i.VorgangspositionID,
		&i.Beschlusstenor,
		&i.Abstimmungsart,
		&i.Mehrheit,
		&i.AbstimmErgebnisBemerkung,
		&i.Dokumentnummer,
		&i.Grundlage,
		&i.Seite,
		&i.CreatedAt,
	)
	return i, err
}

const createUeberweisung = `-- name: CreateUeberweisung :one
INSERT INTO ueberweisung (
    vorgangsposition_id, ausschuss, ausschuss_kuerzel, federfuehrung, ueberweisungsart
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, vorgangsposition_id, ausschuss, ausschuss_kuerzel, federfuehrung, ueberweisungsart, created_at
`

type CreateUeberweisungParams struct {
	VorgangspositionID string         `json:"vorgangsposition_id"`
	Ausschuss          string         `json:"ausschuss"`
	AusschussKuerzel   string         `json:"ausschuss_kuerzel"`
	Federfuehrung      bool           `json:"federfuehrung"`
	Ueberweisungsart   sql.NullString `json:"ueberweisungsart"`
}

func (q *Queries) CreateUeberweisung(ctx context.Context, arg CreateUeberweisungParams) (Ueberweisung, error) {
	row := q.db.QueryRowContext(ctx, createUeberweisung,
		arg.VorgangspositionID,
		arg.Ausschuss,
		arg.AusschussKuerzel,
		arg.Federfuehrung,
		arg.Ueberweisungsart,
	)
	var i Ueberweisung
	err := row.Scan(
		&i.ID,
		&i.VorgangspositionID,
		&i.Ausschuss,
		&i.AusschussKuerzel,
		&i.Federfuehrung,
		&i.Ueberweisungsart,
		&i.CreatedAt,
	)
	return i, err
}

const createVorgangsposition = `-- name: CreateVorgangsposition :one
INSERT INTO vorgangsposition (
    id, vorgang_id, titel, vorgangsposition, vorgangstyp, typ, dokumentart,
    datum, aktualisiert, abstract, fortsetzung, gang, nachtrag, aktivitaet_anzahl,
    kom, ratsdok, sek, zuordnung,
    fundstelle_dokumentnummer, fundstelle_datum, fundstelle_dokumentart,
    fundstelle_herausgeber, fundstelle_id, fundstelle_drucksachetyp,
    fundstelle_anlagen, fundstelle_anfangsseite, fundstelle_endseite,
    fundstelle_anfangsquadrant, fundstelle_endquadrant, fundstelle_seite,
    fundstelle_pdf_url, fundstelle_top, fundstelle_top_zusatz,
    fundstelle_frage_nummer, fundstelle_verteildatum
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
    $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
    $31, $32, $33, $34, $35
) RETURNING id, vorgang_id, titel, vorgangsposition, vorgangstyp, typ, dokumentart, datum, aktualisiert, abstract, fortsetzung, gang, nachtrag, aktivitaet_anzahl, kom, ratsdok, sek, zuordnung, fundstelle_dokumentnummer, fundstelle_datum, fundstelle_dokumentart, fundstelle_herausgeber, fundstelle_id, fundstelle_drucksachetyp, fundstelle_anlagen, fundstelle_anfangsseite, fundstelle_endseite, fundstelle_anfangsquadrant, fundstelle_endquadrant, fundstelle_seite, fundstelle_pdf_url, fundstelle_top, fundstelle_top_zusatz, fundstelle_frage_nummer, fundstelle_verteildatum, created_at, updated_at
`

type CreateVorgangspositionParams struct {
	ID                        string         `json:"id"`
	VorgangID                 string         `json:"vorgang_id"`
	Titel                     string         `json:"titel"`
	Vorgangsposition          string         `json:"vorgangsposition"`
	Vorgangstyp               string         `json:"vorgangstyp"`
	Typ                       string         `json:"typ"`
	Dokumentart               string         `json:"dokumentart"`
	Datum                     time.Time      `json:"datum"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Abstract                  sql.NullString `json:"abstract"`
	Fortsetzung               bool           `json:"fortsetzung"`
	Gang                      bool           `json:"gang"`
	Nachtrag                  bool           `json:"nachtrag"`
	AktivitaetAnzahl          int32          `json:"aktivitaet_anzahl"`
	Kom                       sql.NullString `json:"kom"`
	Ratsdok                   sql.NullString `json:"ratsdok"`
	Sek                       sql.NullString `json:"sek"`
	Zuordnung                 string         `json:"zuordnung"`
	FundstelleDokumentnummer  string         `json:"fundstelle_dokumentnummer"`
	FundstelleDatum           time.Time      `json:"fundstelle_datum"`
	FundstelleDokumentart     string         `json:"fundstelle_dokumentart"`
	FundstelleHerausgeber     string         `json:"fundstelle_herausgeber"`
	FundstelleID              string         `json:"fundstelle_id"`
	FundstelleDrucksachetyp   sql.NullString `json:"fundstelle_drucksachetyp"`
	FundstelleAnlagen         sql.NullString `json:"fundstelle_anlagen"`
	FundstelleAnfangsseite    sql.NullInt32  `json:"fundstelle_anfangsseite"`
	FundstelleEndseite        sql.NullInt32  `json:"fundstelle_endseite"`
	FundstelleAnfangsquadrant sql.NullString `json:"fundstelle_anfangsquadrant"`
	FundstelleEndquadrant     sql.NullString `json:"fundstelle_endquadrant"`
	FundstelleSeite           sql.NullString `json:"fundstelle_seite"`
	FundstellePdfUrl          sql.NullString `json:"fundstelle_pdf_url"`
	FundstelleTop             sql.NullInt32  `json:"fundstelle_top"`
	FundstelleTopZusatz       sql.NullString `json:"fundstelle_top_zusatz"`
	FundstelleFrageNummer     sql.NullString `json:"fundstelle_frage_nummer"`
	FundstelleVerteildatum    sql.NullTime   `json:"fundstelle_verteildatum"`
}

func (q *Queries) CreateVorgangsposition(ctx context.Context, arg CreateVorgangspositionParams) (Vorgangsposition, error) {
	row := q.db.QueryRowContext(ctx, createVorgangsposition,
		arg.ID,
		arg.VorgangID,
		arg.Titel,
		arg.Vorgangsposition,
		arg.Vorgangstyp,
		arg.Typ,
		arg.Dokumentart,
		arg.Datum,
		arg.Aktualisiert,
		arg.Abstract,
		arg.Fortsetzung,
		arg.Gang,
		arg.Nachtrag,
		arg.AktivitaetAnzahl,
		arg.Kom,
		arg.Ratsdok,
		arg.Sek,
		arg.Zuordnung,
		arg.FundstelleDokumentnummer,
		arg.FundstelleDatum,
		arg.FundstelleDokumentart,
		arg.FundstelleHerausgeber,
		arg.FundstelleID,
		arg.FundstelleDrucksachetyp,
		arg.FundstelleAnlagen,
		arg.FundstelleAnfangsseite,
		arg.FundstelleEndseite,
		arg.FundstelleAnfangsquadrant,
		arg.FundstelleEndquadrant,
		arg.FundstelleSeite,
		arg.FundstellePdfUrl,
		arg.FundstelleTop,
		arg.FundstelleTopZusatz,
		arg.FundstelleFrageNummer,
		arg.FundstelleVerteildatum,
	)
	var i Vorgangsposition
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Titel,
		&i.Vorgangsposition,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Dokumentart,
		&i.Datum,
		&i.Aktualisiert,
		&i.Abstract,
		&i.Fortsetzung,
		&i.Gang,
		&i.Nachtrag,
		&i.AktivitaetAnzahl,
		&i.Kom,
		&i.Ratsdok,
		&i.Sek,
		&i.Zuordnung,
		&i.FundstelleDokumentnummer,
		&i.FundstelleDatum,
		&i.FundstelleDokumentart,
		&i.FundstelleHerausgeber,
		&i.FundstelleID,
		&i.FundstelleDrucksachetyp,
		&i.FundstelleAnlagen,
		&i.FundstelleAnfangsseite,
		&i.FundstelleEndseite,
		&i.FundstelleAnfangsquadrant,
		&i.FundstelleEndquadrant,
		&i.FundstelleSeite,
		&i.FundstellePdfUrl,
		&i.FundstelleTop,
		&i.FundstelleTopZusatz,
		&i.FundstelleFrageNummer,
		&i.FundstelleVerteildatum,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVorgangspositionMitberaten = `-- name: CreateVorgangspositionMitberaten :exec
INSERT INTO vorgangsposition_mitberaten (
    vorgangsposition_id, mitberaten_vorgang_id, mitberaten_titel,
    mitberaten_vorgangsposition, mitberaten_vorgangstyp
) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (vorgangsposition_id, mitberaten_vorgang_id) DO UPDATE
SET mitberaten_titel = EXCLUDED.mitberaten_titel,
    mitberaten_vorgangsposition = EXCLUDED.mitberaten_vorgangsposition,
    mitberaten_vorgangstyp = EXCLUDED.mitberaten_vorgangstyp
`

type CreateVorgangspositionMitberatenParams struct {
	VorgangspositionID         string `json:"vorgangsposition_id"`
	MitberatenVorgangID        string `json:"mitberaten_vorgang_id"`
	MitberatenTitel            string `json:"mitberaten_titel"`
	MitberatenVorgangsposition string `json:"mitberaten_vorgangsposition"`
	MitberatenVorgangstyp      string `json:"mitberaten_vorgangstyp"`
}

func (q *Queries) CreateVorgangspositionMitberaten(ctx context.Context, arg CreateVorgangspositionMitberatenParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangspositionMitberaten,
		arg.VorgangspositionID,
		arg.MitberatenVorgangID,
		arg.MitberatenTitel,
		arg.MitberatenVorgangsposition,
		arg.MitberatenVorgangstyp,
	)
	return err
}

const createVorgangspositionRessort = `-- name: CreateVorgangspositionRessort :exec
INSERT INTO vorgangsposition_ressort (vorgangsposition_id, ressort_id, federfuehrend)
VALUES ($1, $2, $3)
ON CONFLICT (vorgangsposition_id, ressort_id) DO UPDATE
SET federfuehrend = EXCLUDED.federfuehrend
`

type CreateVorgangspositionRessortParams struct {
	VorgangspositionID string `json:"vorgangsposition_id"`
	RessortID          int32  `json:"ressort_id"`
	Federfuehrend      bool   `json:"federfuehrend"`
}

func (q *Queries) CreateVorgangspositionRessort(ctx context.Context, arg CreateVorgangspositionRessortParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangspositionRessort, arg.VorgangspositionID, arg.RessortID, arg.Federfuehrend)
	return err
}

const createVorgangspositionUrheber = `-- name: CreateVorgangspositionUrheber :exec
INSERT INTO vorgangsposition_urheber (vorgangsposition_id, urheber_id, rolle, einbringer)
VALUES ($1, $2, $3, $4)
ON CONFLICT (vorgangsposition_id, urheber_id) DO UPDATE
SET rolle = EXCLUDED.rolle,
    einbringer = EXCLUDED.einbringer
`

type CreateVorgangspositionUrheberParams struct {
	VorgangspositionID string         `json:"vorgangsposition_id"`
	UrheberID          int32          `json:"urheber_id"`
	Rolle              sql.NullString `json:"rolle"`
	Einbringer         sql.NullBool   `json:"einbringer"`
}

func (q *Queries) CreateVorgangspositionUrheber(ctx context.Context, arg CreateVorgangspositionUrheberParams) error {
	_, err := q.db.ExecContext(ctx, createVorgangspositionUrheber,
		arg.VorgangspositionID,
		arg.UrheberID,
		arg.Rolle,
		arg.Einbringer,
	)
	return err
}

const deleteVorgangsposition = `-- name: DeleteVorgangsposition :exec
DELETE FROM vorgangsposition WHERE id = $1
`

func (q *Queries) DeleteVorgangsposition(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteVorgangsposition, id)
	return err
}

const getVorgangsposition = `-- name: GetVorgangsposition :one
SELECT 
    vp.id, vp.vorgang_id, vp.titel, vp.vorgangsposition, vp.vorgangstyp, vp.typ, vp.dokumentart, vp.datum, vp.aktualisiert, vp.abstract, vp.fortsetzung, vp.gang, vp.nachtrag, vp.aktivitaet_anzahl, vp.kom, vp.ratsdok, vp.sek, vp.zuordnung, vp.fundstelle_dokumentnummer, vp.fundstelle_datum, vp.fundstelle_dokumentart, vp.fundstelle_herausgeber, vp.fundstelle_id, vp.fundstelle_drucksachetyp, vp.fundstelle_anlagen, vp.fundstelle_anfangsseite, vp.fundstelle_endseite, vp.fundstelle_anfangsquadrant, vp.fundstelle_endquadrant, vp.fundstelle_seite, vp.fundstelle_pdf_url, vp.fundstelle_top, vp.fundstelle_top_zusatz, vp.fundstelle_frage_nummer, vp.fundstelle_verteildatum, vp.created_at, vp.updated_at,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'titel', r.titel,
                'federfuehrend', vpr.federfuehrend
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'
    ) AS ressort,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'bezeichnung', u.bezeichnung,
                'titel', u.titel,
                'rolle', vpu.rolle,
                'einbringer', vpu.einbringer
            )
        ) FILTER (WHERE u.id IS NOT NULL),
        '[]'
    ) AS urheber,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'ausschuss', ue.ausschuss,
                'ausschuss_kuerzel', ue.ausschuss_kuerzel,
                'federfuehrung', ue.federfuehrung,
                'ueberweisungsart', ue.ueberweisungsart
            )
        ) FILTER (WHERE ue.id IS NOT NULL),
        '[]'
    ) AS ueberweisung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'beschlusstenor', bf.beschlusstenor,
                'abstimmungsart', bf.abstimmungsart,
                'mehrheit', bf.mehrheit,
                'abstimm_ergebnis_bemerkung', bf.abstimm_ergebnis_bemerkung,
                'dokumentnummer', bf.dokumentnummer,
                'grundlage', bf.grundlage,
                'seite', bf.seite
            )
        ) FILTER (WHERE bf.id IS NOT NULL),
        '[]'
    ) AS beschlussfassung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'aktivitaetsart', aa.aktivitaetsart,
                'titel', aa.titel,
                'seite', aa.seite,
                'pdf_url', aa.pdf_url
            ) ORDER BY aa.display_order
        ) FILTER (WHERE aa.id IS NOT NULL),
        '[]'
    ) AS aktivitaet_anzeige,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'id', vpm.mitberaten_vorgang_id,
                'titel', vpm.mitberaten_titel,
                'vorgangsposition', vpm.mitberaten_vorgangsposition,
                'vorgangstyp', vpm.mitberaten_vorgangstyp
            )
        ) FILTER (WHERE vpm.mitberaten_vorgang_id IS NOT NULL),
        '[]'
    ) AS mitberaten
FROM vorgangsposition vp
LEFT JOIN vorgangsposition_ressort vpr ON vp.id = vpr.vorgangsposition_id
LEFT JOIN ressort r ON vpr.ressort_id = r.id
LEFT JOIN vorgangsposition_urheber vpu ON vp.id = vpu.vorgangsposition_id
LEFT JOIN urheber u ON vpu.urheber_id = u.id
LEFT JOIN ueberweisung ue ON vp.id = ue.vorgangsposition_id
LEFT JOIN beschlussfassung bf ON vp.id = bf.vorgangsposition_id
LEFT JOIN aktivitaet_anzeige aa ON vp.id = aa.vorgangsposition_id
LEFT JOIN vorgangsposition_mitberaten vpm ON vp.id = vpm.vorgangsposition_id
WHERE vp.id = $1
GROUP BY vp.id
`

type GetVorgangspositionRow struct {
	ID                        string         `json:"id"`
	VorgangID                 string         `json:"vorgang_id"`
	Titel                     string         `json:"titel"`
	Vorgangsposition          string         `json:"vorgangsposition"`
	Vorgangstyp               string         `json:"vorgangstyp"`
	Typ                       string         `json:"typ"`
	Dokumentart               string         `json:"dokumentart"`
	Datum                     time.Time      `json:"datum"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Abstract                  sql.NullString `json:"abstract"`
	Fortsetzung               bool           `json:"fortsetzung"`
	Gang                      bool           `json:"gang"`
	Nachtrag                  bool           `json:"nachtrag"`
	AktivitaetAnzahl          int32          `json:"aktivitaet_anzahl"`
	Kom                       sql.NullString `json:"kom"`
	Ratsdok                   sql.NullString `json:"ratsdok"`
	Sek                       sql.NullString `json:"sek"`
	Zuordnung                 string         `json:"zuordnung"`
	FundstelleDokumentnummer  string         `json:"fundstelle_dokumentnummer"`
	FundstelleDatum           time.Time      `json:"fundstelle_datum"`
	FundstelleDokumentart     string         `json:"fundstelle_dokumentart"`
	FundstelleHerausgeber     string         `json:"fundstelle_herausgeber"`
	FundstelleID              string         `json:"fundstelle_id"`
	FundstelleDrucksachetyp   sql.NullString `json:"fundstelle_drucksachetyp"`
	FundstelleAnlagen         sql.NullString `json:"fundstelle_anlagen"`
	FundstelleAnfangsseite    sql.NullInt32  `json:"fundstelle_anfangsseite"`
	FundstelleEndseite        sql.NullInt32  `json:"fundstelle_endseite"`
	FundstelleAnfangsquadrant sql.NullString `json:"fundstelle_anfangsquadrant"`
	FundstelleEndquadrant     sql.NullString `json:"fundstelle_endquadrant"`
	FundstelleSeite           sql.NullString `json:"fundstelle_seite"`
	FundstellePdfUrl          sql.NullString `json:"fundstelle_pdf_url"`
	FundstelleTop             sql.NullInt32  `json:"fundstelle_top"`
	FundstelleTopZusatz       sql.NullString `json:"fundstelle_top_zusatz"`
	FundstelleFrageNummer     sql.NullString `json:"fundstelle_frage_nummer"`
	FundstelleVerteildatum    sql.NullTime   `json:"fundstelle_verteildatum"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Ressort                   interface{}    `json:"ressort"`
	Urheber                   interface{}    `json:"urheber"`
	Ueberweisung              interface{}    `json:"ueberweisung"`
	Beschlussfassung          interface{}    `json:"beschlussfassung"`
	AktivitaetAnzeige         interface{}    `json:"aktivitaet_anzeige"`
	Mitberaten                interface{}    `json:"mitberaten"`
}

func (q *Queries) GetVorgangsposition(ctx context.Context, id string) (GetVorgangspositionRow, error) {
	row := q.db.QueryRowContext(ctx, getVorgangsposition, id)
	var i GetVorgangspositionRow
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Titel,
		&i.Vorgangsposition,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Dokumentart,
		&i.Datum,
		&i.Aktualisiert,
		&i.Abstract,
		&i.Fortsetzung,
		&i.Gang,
		&i.Nachtrag,
		&i.AktivitaetAnzahl,
		&i.Kom,
		&i.Ratsdok,
		&i.Sek,
		&i.Zuordnung,
		&i.FundstelleDokumentnummer,
		&i.FundstelleDatum,
		&i.FundstelleDokumentart,
		&i.FundstelleHerausgeber,
		&i.FundstelleID,
		&i.FundstelleDrucksachetyp,
		&i.FundstelleAnlagen,
		&i.FundstelleAnfangsseite,
		&i.FundstelleEndseite,
		&i.FundstelleAnfangsquadrant,
		&i.FundstelleEndquadrant,
		&i.FundstelleSeite,
		&i.FundstellePdfUrl,
		&i.FundstelleTop,
		&i.FundstelleTopZusatz,
		&i.FundstelleFrageNummer,
		&i.FundstelleVerteildatum,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Ressort,
		&i.Urheber,
		&i.Ueberweisung,
		&i.Beschlussfassung,
		&i.AktivitaetAnzeige,
		&i.Mitberaten,
	)
	return i, err
}

const listVorgangspositionen = `-- name: ListVorgangspositionen :many
SELECT 
    vp.id, vp.vorgang_id, vp.titel, vp.vorgangsposition, vp.vorgangstyp, vp.typ, vp.dokumentart, vp.datum, vp.aktualisiert, vp.abstract, vp.fortsetzung, vp.gang, vp.nachtrag, vp.aktivitaet_anzahl, vp.kom, vp.ratsdok, vp.sek, vp.zuordnung, vp.fundstelle_dokumentnummer, vp.fundstelle_datum, vp.fundstelle_dokumentart, vp.fundstelle_herausgeber, vp.fundstelle_id, vp.fundstelle_drucksachetyp, vp.fundstelle_anlagen, vp.fundstelle_anfangsseite, vp.fundstelle_endseite, vp.fundstelle_anfangsquadrant, vp.fundstelle_endquadrant, vp.fundstelle_seite, vp.fundstelle_pdf_url, vp.fundstelle_top, vp.fundstelle_top_zusatz, vp.fundstelle_frage_nummer, vp.fundstelle_verteildatum, vp.created_at, vp.updated_at,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'titel', r.titel,
                'federfuehrend', vpr.federfuehrend
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'
    ) AS ressort,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'bezeichnung', u.bezeichnung,
                'titel', u.titel,
                'rolle', vpu.rolle,
                'einbringer', vpu.einbringer
            )
        ) FILTER (WHERE u.id IS NOT NULL),
        '[]'
    ) AS urheber,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'ausschuss', ue.ausschuss,
                'ausschuss_kuerzel', ue.ausschuss_kuerzel,
                'federfuehrung', ue.federfuehrung,
                'ueberweisungsart', ue.ueberweisungsart
            )
        ) FILTER (WHERE ue.id IS NOT NULL),
        '[]'
    ) AS ueberweisung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'beschlusstenor', bf.beschlusstenor,
                'abstimmungsart', bf.abstimmungsart,
                'mehrheit', bf.mehrheit
            )
        ) FILTER (WHERE bf.id IS NOT NULL),
        '[]'
    ) AS beschlussfassung,
    COALESCE(
        json_agg(
            DISTINCT jsonb_build_object(
                'aktivitaetsart', aa.aktivitaetsart,
                'titel', aa.titel,
                'seite', aa.seite,
                'pdf_url', aa.pdf_url
            ) ORDER BY aa.display_order
        ) FILTER (WHERE aa.id IS NOT NULL),
        '[]'
    ) AS aktivitaet_anzeige
FROM vorgangsposition vp
LEFT JOIN vorgangsposition_ressort vpr ON vp.id = vpr.vorgangsposition_id
LEFT JOIN ressort r ON vpr.ressort_id = r.id
LEFT JOIN vorgangsposition_urheber vpu ON vp.id = vpu.vorgangsposition_id
LEFT JOIN urheber u ON vpu.urheber_id = u.id
LEFT JOIN ueberweisung ue ON vp.id = ue.vorgangsposition_id
LEFT JOIN beschlussfassung bf ON vp.id = bf.vorgangsposition_id
LEFT JOIN aktivitaet_anzeige aa ON vp.id = aa.vorgangsposition_id
WHERE 
    ($1::timestamptz IS NULL OR vp.aktualisiert >= $1)
    AND ($2::timestamptz IS NULL OR vp.aktualisiert <= $2)
    AND ($3::date IS NULL OR vp.datum >= $3)
    AND ($4::date IS NULL OR vp.datum <= $4)
    AND ($5::text IS NULL OR vp.vorgang_id = $5)
    AND ($6::text IS NULL OR vp.dokumentart = $6)
    AND ($7::text IS NULL OR vp.fundstelle_dokumentnummer = $7)
    AND ($8::text IS NULL OR vp.zuordnung = $8)
GROUP BY vp.id
ORDER BY vp.datum DESC
LIMIT $9 OFFSET $10
`

type ListVorgangspositionenParams struct {
	Column1 time.Time `json:"column_1"`
	Column2 time.Time `json:"column_2"`
	Column3 time.Time `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 string    `json:"column_5"`
	Column6 string    `json:"column_6"`
	Column7 string    `json:"column_7"`
	Column8 string    `json:"column_8"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListVorgangspositionenRow struct {
	ID                        string         `json:"id"`
	VorgangID                 string         `json:"vorgang_id"`
	Titel                     string         `json:"titel"`
	Vorgangsposition          string         `json:"vorgangsposition"`
	Vorgangstyp               string         `json:"vorgangstyp"`
	Typ                       string         `json:"typ"`
	Dokumentart               string         `json:"dokumentart"`
	Datum                     time.Time      `json:"datum"`
	Aktualisiert              time.Time      `json:"aktualisiert"`
	Abstract                  sql.NullString `json:"abstract"`
	Fortsetzung               bool           `json:"fortsetzung"`
	Gang                      bool           `json:"gang"`
	Nachtrag                  bool           `json:"nachtrag"`
	AktivitaetAnzahl          int32          `json:"aktivitaet_anzahl"`
	Kom                       sql.NullString `json:"kom"`
	Ratsdok                   sql.NullString `json:"ratsdok"`
	Sek                       sql.NullString `json:"sek"`
	Zuordnung                 string         `json:"zuordnung"`
	FundstelleDokumentnummer  string         `json:"fundstelle_dokumentnummer"`
	FundstelleDatum           time.Time      `json:"fundstelle_datum"`
	FundstelleDokumentart     string         `json:"fundstelle_dokumentart"`
	FundstelleHerausgeber     string         `json:"fundstelle_herausgeber"`
	FundstelleID              string         `json:"fundstelle_id"`
	FundstelleDrucksachetyp   sql.NullString `json:"fundstelle_drucksachetyp"`
	FundstelleAnlagen         sql.NullString `json:"fundstelle_anlagen"`
	FundstelleAnfangsseite    sql.NullInt32  `json:"fundstelle_anfangsseite"`
	FundstelleEndseite        sql.NullInt32  `json:"fundstelle_endseite"`
	FundstelleAnfangsquadrant sql.NullString `json:"fundstelle_anfangsquadrant"`
	FundstelleEndquadrant     sql.NullString `json:"fundstelle_endquadrant"`
	FundstelleSeite           sql.NullString `json:"fundstelle_seite"`
	FundstellePdfUrl          sql.NullString `json:"fundstelle_pdf_url"`
	FundstelleTop             sql.NullInt32  `json:"fundstelle_top"`
	FundstelleTopZusatz       sql.NullString `json:"fundstelle_top_zusatz"`
	FundstelleFrageNummer     sql.NullString `json:"fundstelle_frage_nummer"`
	FundstelleVerteildatum    sql.NullTime   `json:"fundstelle_verteildatum"`
	CreatedAt                 time.Time      `json:"created_at"`
	UpdatedAt                 time.Time      `json:"updated_at"`
	Ressort                   interface{}    `json:"ressort"`
	Urheber                   interface{}    `json:"urheber"`
	Ueberweisung              interface{}    `json:"ueberweisung"`
	Beschlussfassung          interface{}    `json:"beschlussfassung"`
	AktivitaetAnzeige         interface{}    `json:"aktivitaet_anzeige"`
}

func (q *Queries) ListVorgangspositionen(ctx context.Context, arg ListVorgangspositionenParams) ([]ListVorgangspositionenRow, error) {
	rows, err := q.db.QueryContext(ctx, listVorgangspositionen,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVorgangspositionenRow
	for rows.Next() {
		var i ListVorgangspositionenRow
		if err := rows.Scan(
			&i.ID,
			&i.VorgangID,
			&i.Titel,
			&i.Vorgangsposition,
			&i.Vorgangstyp,
			&i.Typ,
			&i.Dokumentart,
			&i.Datum,
			&i.Aktualisiert,
			&i.Abstract,
			&i.Fortsetzung,
			&i.Gang,
			&i.Nachtrag,
			&i.AktivitaetAnzahl,
			&i.Kom,
			&i.Ratsdok,
			&i.Sek,
			&i.Zuordnung,
			&i.FundstelleDokumentnummer,
			&i.FundstelleDatum,
			&i.FundstelleDokumentart,
			&i.FundstelleHerausgeber,
			&i.FundstelleID,
			&i.FundstelleDrucksachetyp,
			&i.FundstelleAnlagen,
			&i.FundstelleAnfangsseite,
			&i.FundstelleEndseite,
			&i.FundstelleAnfangsquadrant,
			&i.FundstelleEndquadrant,
			&i.FundstelleSeite,
			&i.FundstellePdfUrl,
			&i.FundstelleTop,
			&i.FundstelleTopZusatz,
			&i.FundstelleFrageNummer,
			&i.FundstelleVerteildatum,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Ressort,
			&i.Urheber,
			&i.Ueberweisung,
			&i.Beschlussfassung,
			&i.AktivitaetAnzeige,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVorgangsposition = `-- name: UpdateVorgangsposition :one
UPDATE vorgangsposition
SET 
    titel = $2,
    aktualisiert = $3,
    abstract = $4,
    aktivitaet_anzahl = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, vorgang_id, titel, vorgangsposition, vorgangstyp, typ, dokumentart, datum, aktualisiert, abstract, fortsetzung, gang, nachtrag, aktivitaet_anzahl, kom, ratsdok, sek, zuordnung, fundstelle_dokumentnummer, fundstelle_datum, fundstelle_dokumentart, fundstelle_herausgeber, fundstelle_id, fundstelle_drucksachetyp, fundstelle_anlagen, fundstelle_anfangsseite, fundstelle_endseite, fundstelle_anfangsquadrant, fundstelle_endquadrant, fundstelle_seite, fundstelle_pdf_url, fundstelle_top, fundstelle_top_zusatz, fundstelle_frage_nummer, fundstelle_verteildatum, created_at, updated_at
`

type UpdateVorgangspositionParams struct {
	ID               string         `json:"id"`
	Titel            string         `json:"titel"`
	Aktualisiert     time.Time      `json:"aktualisiert"`
	Abstract         sql.NullString `json:"abstract"`
	AktivitaetAnzahl int32          `json:"aktivitaet_anzahl"`
}

func (q *Queries) UpdateVorgangsposition(ctx context.Context, arg UpdateVorgangspositionParams) (Vorgangsposition, error) {
	row := q.db.QueryRowContext(ctx, updateVorgangsposition,
		arg.ID,
		arg.Titel,
		arg.Aktualisiert,
		arg.Abstract,
		arg.AktivitaetAnzahl,
	)
	var i Vorgangsposition
	err := row.Scan(
		&i.ID,
		&i.VorgangID,
		&i.Titel,
		&i.Vorgangsposition,
		&i.Vorgangstyp,
		&i.Typ,
		&i.Dokumentart,
		&i.Datum,
		&i.Aktualisiert,
		&i.Abstract,
		&i.Fortsetzung,
		&i.Gang,
		&i.Nachtrag,
		&i.AktivitaetAnzahl,
		&i.Kom,
		&i.Ratsdok,
		&i.Sek,
		&i.Zuordnung,
		&i.FundstelleDokumentnummer,
		&i.FundstelleDatum,
		&i.FundstelleDokumentart,
		&i.FundstelleHerausgeber,
		&i.FundstelleID,
		&i.FundstelleDrucksachetyp,
		&i.FundstelleAnlagen,
		&i.FundstelleAnfangsseite,
		&i.FundstelleEndseite,
		&i.FundstelleAnfangsquadrant,
		&i.FundstelleEndquadrant,
		&i.FundstelleSeite,
		&i.FundstellePdfUrl,
		&i.FundstelleTop,
		&i.FundstelleTopZusatz,
		&i.FundstelleFrageNummer,
		&i.FundstelleVerteildatum,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
